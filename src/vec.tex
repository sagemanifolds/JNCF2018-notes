\chapter{Vector fields} \label{s:vec}

\minitoc

\section{Introduction}

This chapter is devoted to the most basic objects of tensor calculus:
vector fields. We start by defining tangent vectors and tangent spaces
on a differentiable manifold (Sec.~\ref{s:vec:tangent_vectors}), and then
move to vector fields (Sec.~\ref{s:vec:vector_fields}).

\section{Tangent vectors} \label{s:vec:tangent_vectors}

\subsection{Definitions} \label{s:vec:def_tangent_vector}

Let $\M$ be a smooth manifold of dimension $n$ over the topological field $\K$
and $C^\infty(M)$ the corresponding algebra of scalar fields introduced in Sec.~\ref{s:man:scal_algebra}.
For $p\in M$, a \defin{tangent vector at}\index{tangent!vector} $p$ is
a map
\be
    \w{v}: C^\infty(M) \longrightarrow \K
\ee
such that (i) $\w{v}$ is $\K$-linear and (ii) $\w{v}$ obeys
\be \label{e:vec:derivation}
    \forall f,g \in C^\infty(M),\quad
        \w{v}(fg) = \w{v}(f) g(p) + f(p) \w{v}(g) .
\ee
Because of property (\ref{e:vec:derivation}), one says that $\w{v}$ is
a \defin{derivation at} $p$.

The set $T_p\M$ of all tangent vectors at $p$ is a vector space of dimension
$n$ over $\K$; it is called the \defin{tangent space to} $\M$
\defin{at}\index{tangent!space} $p$.

\subsection{SageMath implementation} \label{s:vec:tangent_impl}

To illustrate the implementation of tangent vectors in \Sage{}, we shall
consider the same example $M=\Sp$ as in Chap.~\ref{s:man}. First of all,
we recreate the same objects as in Chap.~\ref{s:man}, starting with the manifold
$M$ and its two stereographic charts $X_U = (U,(x,y))$ and $X_V = (V,(x',y'))$,
with $M=U\cup V$ (the full Jupyter notebook is available at
\url{http://sagemanifolds.obspm.fr/jncf2018/}):
\jup{ve01.png}
\jup{ve02.png}
Then we introduce the point $p\in U$ of coordinates $(x,y)=(1,2)$:
\jup{ve03.png}
The canonical embedding of $\Sp$ in $\R^3$ is defined mostly for
graphical purposes:
\jup{ve04.png}
\jup{ve05.png}
Finally, the last objects defined in Chap.~\ref{s:man} are the
scalar field $f$:
\jup{ve06.png}
and its parent, namely the commutative algebra $C^\infty(\M)$ of
smooth maps $\M\to\R$:
\jup{ve07.png}

The tangent space at the point $p$ introduced in \code{In~[3]} is generated by
\jup{ve08.png}
It is a vector space over $\K$ (here $\K=\R$, which is represented by \Sage{}'s Symbolic
Ring \code{SR}):
\jup{ve09.png}
The dimension of the vector space $T_p\M$ equals that of the manifold $\M$:
\jup{ve10.png}
Tangent spaces are implemented as a class inherited from \code{TangentSpace}
via the category framework:
\jup{ve11.png}
The class \code{TangentSpace} itself inherits from the generic class
\code{FiniteRankFreeModule}\footurl{http://doc.sagemath.org/html/en/reference/tensor_free_modules/sage/tensor/modules/finite_rank_free_module.html}, which, in \Sage{}, is devoted to free modules of finite rank
without any distinguished basis:
\jup{ve12.png}
\begin{remark}
In \Sage{}, free modules with a distinguished basis
are created with the command \code{FreeModule} or \code{VectorSpace}
and belong to classes different from \code{FiniteRankFreeModule}.
The differences are illustrated at\\
{\scriptsize \url{http://doc.sagemath.org/html/en/reference/modules/sage/tensor/modules/finite_rank_free_module.html#diff-freemodule}}.
\end{remark}

Two bases of $T_p\M$ are already available: those generated by the derivations
at $p$ along the coordinates of charts \code{XU} and \code{XV} respectively:
\jup{ve13.png}
None of these bases is distinguished, but one if the default one, which
simply means that it is the basis to be considered if the basis argument
is skipped in some methods:
\jup{ve14.png}

A tangent vector is created as an element of the tangent space by the
standard \Sage{} procedure\index{parent}\index{element}
\code{new\_element = parent(...)}, where \code{...}
stands for some material sufficient to construct the element:
\jup{ve15.png}
Since the basis is not specified, the pair $(-3,2)$ refers to components
with respect to the default basis:
\jup{ve16.png}
We have of course
\jup{ve17.png}
\jup{ve18.png}
As other manifold objects, tangent vectors have some plotting capabilities:
\jup{ve19.png}
The main attribute of the object \code{vp} representing the vector $\w{v}$ is the
private dictionary \code{\_components}, which stores the components of $\w{v}$ in various bases of $T_p M$:
\jup{ve20.png}
The keys of the dictionary \code{\_components} are the bases of $T_p M$, while the values belong to the class \code{Components}\footurl{http://doc.sagemath.org/html/en/reference/tensor_free_modules/sage/tensor/modules/comp.html} devoted to store ring elements indexed by integers or tuples of integers:
\jup{ve21.png}
\jup{ve22.png}
The components themselves are stored in the private dictionary \code{\_comp} of the \code{Components} object, with the indices as keys:
\jup{ve23.png}
Hence the components are not stored via a sequence data type (list or tuple), as
one might have expected, but via a mapping type (dictionary). This is a general
feature of the class \code{Components} and all its subclasses, which permits
to not store vanishing components and, in case of symmetries (for multi-index
objects like tensors), to store only non-redundant components.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Vector fields} \label{s:vec:vector_fields}

\subsection{Definition}

The \defin{tangent bundle}\index{tangent!bundle} of $\M$ is the disjoint union
of the tangent spaces at all points of $\M$:
\be
    T\M = \coprod_{p\in\M} T_p \M .
\ee
Elements of $T\M$ are usually denoted by $(p, \w{u})$, with $\w{u}\in T_p\M$.
The tangent bundle is canonically endowed with the
\defin{projection map}\index{projection!map}:
\be
    \begin{array}{cccc}
    \pi : & T\M & \longrightarrow & \M \\
        & (p,\w{u}) & \longmapsto & p .
    \end{array}
\ee

The tangent bundle inherits some manifold structure from $\M$:
$T\M$ is a smooth manifold of dimension $2n$ over $\K$ ($n$ being the dimension
of $\M$).

A \defin{vector field}\index{vector!field} on $\M$ is a continuous
right-inverse of the projection map, i.e. it is a map
\be
    \begin{array}{cccc}
    \w{v} : & \M & \longrightarrow & T\M \\
        & p & \longmapsto & \left. \w{v}\right| _p
    \end{array}
\ee
such that $\pi\circ \w{v} = \mathrm{Id}_{\M}$, i.e. such that
\be
    \forall p\in \M, \quad \left. \w{v}\right| _p \in T_p\M .
\ee

\subsection{Module of vector fields} \label{s:vec:vector_module}

The set $\X(\M)$ of all vector fields on $\M$
is naturally endowed with two algebraic structures:
\begin{enumerate}
\item $\X(\M)$ is a (infinite dimensional) vector space over $\K$ --- the base field of $\M$ ---,
the scalar multiplication $\K\times\X(M)\to \X(M)$, $(\lambda,\w{v})\mapsto \lambda \w{v}$
being defined by
\be
    \forall p\in\M,
    \quad \left. (\lambda \w{v}) \right| _p =  \left. \lambda \w{v} \right| _p,
\ee
where
the right-hand side involves the scalar multiplication
in the vector space $T_p\M$;
\item $\X(\M)$ is a module\index{module} over $C^\infty(M)$ --- the commutative
algebra of scalar fields ---,
the scalar multiplication $C^\infty(M)\times\X(M)\to \X(M)$, $(f,\w{v})\mapsto f \w{v}$
being defined by
\be
    \forall p\in\M,
    \quad \left. (f \w{v}) \right| _p = \left.f(p)  \w{v} \right| _p ,
\ee
where
the right-hand side involves the scalar multiplication by $f(p)\in \K$
in the vector space $T_p\M$.
\end{enumerate}
An important subcase of 2 is when $\X(\M)$ is a
\defin{free module}\index{free module}\index{module!free --} over $C^\infty(M)$,
i.e. when $\X(\M)$ admits a basis\index{basis} (a generating set consisting of linearly independent elements). If this occurs, then $\X(\M)$ is actually a
\defin{free module of finite rank}\index{free module!of finite rank}\index{finite rank!free module of --} over $C^\infty(M)$ and its rank is $n$ -- the dimension of
$\M$ over $\K$, which means that all bases share the same cardinality, namely $n$.
One says that $\M$ is a \defin{parallelizable}\index{parallelizable} manifold.
A basis $(\w{e}_a)_{1\leq a \leq n}$ of $\X(\M)$ is called a
\defin{vector frame}\index{vector!frame};
for any $p\in\M$, $(\left.\w{e}_a \right| _p)_{1\leq a \leq n}$
is then a basis of the tangent vector space $T_p\M$.
Any vector field has a unique decomposition with respect to the vector
frame\footnote{Einstein's convention for summation on repeated indices is assumed.} $(\w{e}_a)_{1\leq a \leq n}$:
\be \label{e:vec:v_expand}
    \forall \w{v}\in\X(\M),\quad \w{v} = v^a \w{e}_a,\quad\mbox{with\ } v^a \in C^\infty(\M) .
\ee
At each point $p\in \M$, Eq.~(\ref{e:vec:v_expand}) gives birth to an identity in
the tangent space $T_p \M$:
\be
    \left.\w{v} \right| _p = v^a(p)  \left.\w{e}_a \right| _p,\quad\mbox{with\ } v^a(p) \in \K ,
\ee
which is nothing but the expansion of the tangent vector $\left.\w{v} \right| _p$
on the basis $(\left.\w{e}_a \right| _p)_{1\leq a \leq n}$ of the
vector space $T_p \M$.

Note that if $\M$ is covered by a chart $X$, i.e. $\M$ is the domain of
the chart $X$, then $\M$ is parallelizable and a vector frame
is $(\partial/\partial x^a)_{1\leq a \leq n}$, where the $x^a$'s are
the coordinates of chart $X$. Such a vector frame is called a
\defin{coordinate frame}\index{coordinate!frame} or \defin{natural basis}\index{natural basis}. More generally, examples of parallelizable manifolds are
\cite{Lee13}
\begin{itemize}
\item the Cartesian space $\mathbb{R}^n$ for $n=1,2,\ldots$,
\item the circle $\mathbb{S}^1$,
\item the torus $\mathbb{T}^2 = \mathbb{S}^1\times \mathbb{S}^1$,
\item the sphere $\mathbb{S}^3 \simeq \mathrm{SU}(2)$, as any Lie group,
\item the sphere $\mathbb{S}^7$,
\item any orientable 3-manifold (Steenrod theorem \cite{Steen51}).
\end{itemize}
On the other hand, examples of non-parallelizable manifolds are
\begin{itemize}
\item the sphere $\mathbb{S}^2$ (as a consequence of the hairy ball theorem),
as well as any sphere $\mathbb{S}^n$ with $n\not\in\{1,3,7\}$,
\item the real projective plane $\mathbb{RP}^2$.
\end{itemize}
Actually, ``most'' manifolds are non-parallelizable.
As noticed above, if a manifold is covered by a single chart, it is
parallelizable (the prototype being $\mathbb{R}^n$). But the reverse is not
true: $\mathbb{S}^1$ and $\mathbb{T}^2$ are parallelizable and require
at least two charts to cover them.

\subsection{SageMath implementation} \label{s:vec:vector_field_impl}

Among the two algebraic structures for $\X(\M)$ discussed in Sec.~\ref{s:vec:vector_module},
we select the second one, i.e. we consider $\X(\M)$ as a $C^\infty(M)$-module.
With respect to the infinite-dimensional $\K$-vector space point of view,
the advantage for the implementation is the reduction to finite-dimensional structures: free modules of rank $n$ on parallelizable open subsets of $\M$.
Indeed, if $U$ is such an open subset, i.e. if $\X(U)$ is a free $C^\infty(U)$-module
of rank $n$, the generic class \code{FiniteRankFreeModule} discussed in
Sec.~\ref{s:vec:tangent_impl} can be used to implement $\X(U)$. The great benefit
is that all calculus implemented on the free module elements, like the addition
or the scalar multiplication, can be used as such for vector fields.
This implies that vector fields will be described by their (scalar-field) components
on vector frames, as defined by Eq.~(\ref{e:vec:v_expand}), on parallelizable
open subsets of $\M$.

If the manifold $\M$ is not parallelizable,
we assume that it can be covered by a finite number $m$
of parallelizable open subsets $U_i$ ($1\leq i \leq m$):
\be
    M = \bigcup_{i=1}^m U_i, \qquad\mbox{with}\quad U_i\ \mbox{parallelizable}
\ee
In particular, this holds if $\M$ is compact, for any compact
manifold admits a finite atlas.

For each $i\in\{1,\ldots,m\}$, $\X(U_i)$ is a free module of rank $n=\dim  M$ and is implemented in SageMath as an instance of
\code{VectorFieldFreeModule}, which is a subclass of
\code{FiniteRankFreeModule}. This inheritance is illustrated in
Fig.~\ref{f:vec:module_classes}. On that figure, we note that the class
\code{TangentSpace} discussed in Sec.~\ref{s:vec:tangent_impl} inherits from\\
\code{FiniteRankFreeModule} as well.

\begin{figure}
\begin{center}
\input{module_classes_tikz}
\end{center}
\caption{\label{f:vec:module_classes} \footnotesize
\Sage{} classes for modules involved in differentiable manifolds.}
\end{figure}


A vector field $\w{v}\in\X(M)$ is then described by its
restrictions $\left(\left. \w{v}\right| _{U_i}\right)_{1\leq i \leq m}$ to each of the $U_i$'s.
Assuming that at least one vector frame is introduced in each of the $U_i$'s,
$(\w{e}_{i,a})_{1\leq a \leq n}$ say, the restriction $\left. \w{v}\right| _{U_i}$ of
$\w{v}$ to $U_i$ is decribed by its components $v_i^a$ in that frame:
\be \label{e:vec:vi_expand}
    \left. \w{v}\right| _{U_i} = v_i^a \, \w{e}_{i,a},\quad\mbox{with\ } v_i^a \in C^\infty(U_i) .
\ee

Let us illustrate this strategy with the example of $\Sp$.
We get $\X(\M)$ by\footnote{We are using \code{YM} to denote $\X(\M)$ and not \code{XM}, because we reserve the symbol \code{X} to denote coordinate charts, as
\code{XU}, \code{XV} or \code{XR3}.}
\jup{ve24.png}
As discussed above, $\X(\M)$ is considered as a module over $C^\infty(M)$:
\jup{ve25.png}
Since the algebra $C^\infty(M)$ is denoted \code{CM}, we have
\jup{ve26.png}
$\X(\M)$ is not a free module; in particular, we can check that its \Sage{} implementation does not
belong to the class \code{FiniteRankFreeModule}:
\jup{ve27.png}
This is because $M=\Sp$ is not a parallelizable manifold:
\jup{ve28.png}
Via \Sage{} category framework,
the module $\X(\M)$ is implemented by a dynamically-generated subclass
of the class \code{VectorFieldModule}, which is devoted to modules of vector fields
on non-parallelizable manifolds:
\jup{ve29.png}

On the contrary, the set $\mathfrak{X}(U)$ of vector fields on $U$ is a free module of
finite rank over the algebra $C^\infty(U)$:
\jup{ve30.png}
\jup{ve31.png}
This is because the open subset $U$ is a parallelizable manifold:
\jup{ve32.png}
being the domain of a coordinate chart:
\jup{ve33.png}
We can check that in $U$'s atlas, at least one chart has $U$ for domain:
\jup{ve34.png}
This chart is \code{XU} = $(U, (x,y))$, i.e. the chart of stereographic coordinates
from the North pole.
The rank of $\X(U)$ as a free $C^\infty(U)$-module is the manifold's dimension:
\jup{ve35.png}
Via the category framework,
the free module $\X(U)$ is implemented by a dynamically-generated subclass
of the class \code{VectorFieldFreeModule}, which is devoted to modules of vector fields
on parallelizable manifolds:
\jup{ve36.png}
The class \code{VectorFieldFreeModule} is itself a subclass
of the generic class\\ \code{FiniteRankFreeModule}:
\jup{ve37.png}

Since $U$ is a chart domain, the free module $\X(U)$ is automatically endowed with a basis,
which is the coordinate frame associated to the chart:
\jup{ve38.png}
Let us denote by \code{eU} this frame. We can set \code{eU = YU.bases()[0]} or
alternatively
\jup{ve39.png}
Another equivalent instruction would have been \code{eU = U.default\_frame()}.

Similarly, $\X(V)$ is a free module, endowed with the coordinate frame
associated to stereographic coordinates from the South pole, which we
denote by \code{eV}:
\jup{ve40.png}
\jup{ve41.png}

If we consider the intersection $W=U\cap V$, we notice its module
of vector fields is endowed with two bases, reflecting the fact that
$W$ is covered by two charts: $(W,(x,y))$ and $(W,(x',y'))$:
\jup{ve42.png}
Let us denote by \code{eUW} and \code{eUV} these two bases, which are
actually the restrictions of the vector frames \code{eU} and \code{eV} to
$W$:
\jup{ve43.png}
The free module $\X(W)$ is also automatically endowed with automorphisms
connecting the two bases, i.e. change-of-frame operators:
\jup{ve44.png}
The first of them is
\jup{ve45.png}
It belongs to the general linear group of the free module $\X(W)$:
\jup{ve46.png}
and its matrix is deduced from the Jacobian matrix of the transition map
\code{XV} $\to$ \code{XU}:
\jup{ve47.png}

\subsection{Construction and manipulation of vector fields}

Let us introduce a vector field $\w{v}$ on $\M$:
\jup{ve48.png}
Notice that, at this stage, we have defined $\w{v}$ only on $U$, by setting
its components in the vector frame \code{eU}, either explicitly as scalar
fields, like the component $v^0$ set to the restriction of $f$ to $U$ or
implicitly, like the component $v^1$: the integer \code{-2}
will be coerced to the constant scalar field of value $-2$ (cf. Sec.~\ref{s:man:add_implement}).
We can ask for the scalar-field value of a component via the double-bracket
operator; since \code{eU} is the default frame on $M$, we do not have to specify
it:
\jup{ve49.png}
\jup{ve50.png}
Note that, for convenience, the single bracket operator returns a chart function
of the component:
\jup{ve51.png}
The restriction of $\w{v}$ to $W$ is of course
\jup{ve52.png}
Since we have a second vector frame on $W$, namely \code{eVW}, and the
change-of-frame automorphisms are known, we can ask for the components
of $\w{v}$ with respect to that frame:
\jup{ve53.png}
Notice that the components are expressed in terms of the coordinates $(x,y)$
since they form the default chart on $W$. To have them expressed in
terms of the coordinates $(x',y')$, we have to add the restriction of
the chart
$(V,(x',y'))$ to $W$ as the second argument of the method
\code{display()}:
\jup{ve54.png}
We extend the expression of $\w{v}$ to the full vector frame \code{XV}
by continuation of this expression:
\jup{ve55.png}
We have then
\jup{ve56.png}
At this stage, the vector field $\w{v}$ is defined in all $M$.
According to the hairy ball theorem\index{hairy ball theorem}, it has to vanish somewhere.
Let us show that this occurs at the North pole, by first introducing the
latter, as the point of stereographic coordinates $(x',y')=(0,0)$:
\jup{ve57.png}
As a check, we verify that the image of $N$ by the canonical embedding
$\Phi: \Sp \to \R^3$ is the point of Cartesian coordinates $(0,0,1)$:
\jup{ve58.png}
The vanishing of $\left.\w{v}\right| _N$:
\jup{ve59.png}
On the other hand, $\w{v}$ does not vanish at the point $p$ introduced above:
\jup{ve60.png}

We may plot the vector field $\w{v}$ in terms of the stereographic coordinates
from the North pole:
\jup{ve61a.png}
\jup{ve61b.png}
or in term of those from the South pole:
\jup{ve62.png}
Thanks to the embedding $\Phi$, we may also have a 3D plot of the vector
field $\w{v}$
atop of the 3D plot already obtained:
\jup{ve63.png}
Note that the sampling, performed on the two charts \code{XU} and \code{XV}
is not uniform on the sphere. A better sampling would be achieved by introducing
spherical coordinates.

\subsection{Implementation details regarding vector fields}

Let us now investigate some internals of the implementation of vector fields.
Vector fields on $M$ are implemented via the class
\code{VectorField}\footurl{http://doc.sagemath.org/html/en/reference/manifolds/sage/manifolds/differentiable/vectorfield.html} (actually by a dynamically generated subclass of it, within \Sage{} category
framework):
\jup{ve64.png}

Since $M$ is not parallelizable, the defining data of a
vector field $\w{v}$ on $M$ are its restrictions
$\left(\left. \w{v}\right| _{U_i}\right)_{1\leq i \leq m}$
to parallelizable open subsets $U_i$,
following the scheme presented in Sec.~\ref{s:vec:vector_field_impl}.
These restrictions are stored in the private dictionary \code{\_restrictions}, whose keys are
the open subsets:
\jup{ve65.png}
Let us consider one of these restrictions, for instance the restriction
$\left. \w{v}\right| _U$ to $U$:
\jup{ve66.png}
Since $U$ is a parallelizable open subset, the object \code{vU} belongs
to the class \code{VectorFieldParal}, which is devoted to vector fields
on parallelizable manifolds:
\jup{ve67.png}
The class \code{VectorFieldParal} inherits both from
\code{FiniteRankFreeModuleElement} (as \code{TangentVector}) and from
\code{VectorField} (see Fig.~\ref{f:vec:tensorfield_classes}).
\begin{figure}
\begin{center}
\input{tensorfield_classes_tikz}
\end{center}
\caption{\label{f:vec:tensorfield_classes}\footnotesize
\Sage{} classes for tensor fields involved in differentiable manifolds.
There are various multiple inheritances involving diamond diagrams;
Python's method resolution order algorithm (MRO) relies on the ordering of the parents
in the class declaration and this order can be read from the left to the right in
this figure. For instance, the class \code{VectorFieldParal} is declared as
\code{class VectorFieldParal(FiniteRankFreeModuleElement, MultivectorFieldParal, VectorField)}.}
\end{figure}
The defining data of $\left. \w{v}\right| _U$ are
its sets of components with respect to (possibly various)
vector frames on $U$, according to Eq.~(\ref{e:vec:vi_expand}). The sets of components are stored in the private dictionary \code{\_components}, whose keys are the vector frames:
\jup{ve68.png}
Similarly, we have:
\jup{ve69.png}
The values of the dictionary \code{\_components} belong to the same class
\code{Components} as that discussed in Sec.~\ref{s:vec:tangent_impl} for
the storage of components of tangent vectors:
\jup{ve70.png}
\jup{ve71.png}
As already mentioned in Sec.~\ref{s:vec:tangent_impl}, the components themselves are stored
in the private attribute \code{\_comp} of the \code{Components} object; this is a dictionary
whose keys are the indices:
\jup{ve72.png}
The difference with the tangent vector case is that the values of that dictionary are now scalar fields, i.e. elements of $C^\infty(U)$ in the present case. This is of course in agreement with the treatment of $\mathfrak{X}(U)$ as a free module over $C^\infty(U)$,
as discussed in Sec.~\ref{s:vec:vector_field_impl}.
Taking into account the storage of scalar fields presented in Sec.~\ref{s:man:def_scalar},
the full storage structure of vector fields is presented in Fig.~\ref{f:vec:storage_tensor}
(the latter actually regards tensor fields, of which vector fields constitute a subcase).

\begin{figure}
\begin{center}
\input{tensorfield_structure_tikz}
\end{center}
\caption{\label{f:vec:storage_tensor} \footnotesize
Internal storage of tensor fields. Red boxes
represent Python dictionaries, yellow boxes are dictionary values, with the corresponding
dictionary key located on the left of them.
The Python class of each dictionary value is indicated in typewriter font at the top of the
yellow box. In the hierarchical tree, only the leftmost
branch is indicated by grey connectors. In the special case of vector fields, the classes
\code{TensorField} and \code{TensorFieldParal} are to be replaced by \code{VectorField} and \code{VectorFieldParal} respectively.}
\end{figure}

Let us perform some algebraic operation on vector fields:
\jup{ve73.png}
The code for the addition is accessible via
\jup{ve74.png}
\begin{lstlisting}
File: .../src/sage/structure/element.pyx
def __add__(left, right):
    """
    Top-level addition operator for :class:`Element` invoking
    the coercion model.

    See :ref:`element_arithmetic`.
    ...
    """
    cdef int cl = classify_elements(left, right)
    if HAVE_SAME_PARENT(cl):
        return (<Element>left)._add_(right)
    # Left and right are Sage elements => use coercion model
    if BOTH_ARE_ELEMENT(cl):
        return coercion_model.bin_op(left, right, add)
    ...
\end{lstlisting}
This is exactly the same method \code{\_\_add\_\_()} as that discussed in
Sec.~\ref{s:man:add_implement} for the addition of scalar fields (cf. page~\pageref{p:man:list___add__}), namely
the method \code{\_\_add\_\_()} of the top-level class \code{Element}, from
which both \code{VectorField} and \code{DiffScalarField} inherit, cf. the inheritance
diagrams of Figs.~\ref{f:vec:tensorfield_classes} and
\ref{f:man:scalar_classes} (taking into account that
\code{CommutativeAlgebraElement} is a subclass of \code{Element}).
In the present case, \code{left} = \code{v} and \code{right} = \code{f*v}
have the same parent, so that the actual result is computed in line~12,
via the method \code{\_add\_()}
(note the single underscore on each side of \code{add}). This operator is
implemented at the level of \code{TensorField}, as it can be checked from the source code
(see lines~3 and 29 below):
\jup{ve75.png}
\begin{lstlisting}
def _add_(self, other):
    """
    Tensor field addition.

    INPUT:

    - ``other`` -- a tensor field, in the same tensor module as ``self``

    OUTPUT:

    - the tensor field resulting from the addition of ``self``
      and ``other``
    ...
    """
    resu_rst = {}
    for dom in self._common_subdomains(other):
        resu_rst[dom] = self._restrictions[dom] + other._restrictions[dom]
    some_rst = next(itervalues(resu_rst))
    resu_sym = some_rst._sym
    resu_antisym = some_rst._antisym
    resu = self._vmodule.tensor(self._tensor_type, sym=resu_sym,
                                antisym=resu_antisym)
    resu._restrictions = resu_rst
    if self._name is not None and other._name is not None:
        resu._name = self._name + '+' + other._name
    if self._latex_name is not None and other._latex_name is not None:
        resu._latex_name = self._latex_name + '+' + other._latex_name
    return resu
File:  .../site-packages/sage/manifolds/differentiable/tensorfield.py
\end{lstlisting}
The first step in the addition of two vector fields is to search in the
restrictions of both vector fields for common domains: this is performed in
line~16, via the method \code{\_common\_subdomains}. Then the addition is
performed at the level of the restrictions, in line~17. The rest of the code
is simply the set up of the vector field object containing the result.
Recursively, the addition performed in line~17 will reach a level at which
the domains are parallelizable. Then a different method \code{\_add\_()}, will
be involved, as we can check on \code{vU}:
\jup{ve76.png}
\begin{lstlisting}
def _add_(self, other):
    """
    Tensor addition.

    INPUT:

    - ``other`` -- a tensor, of the same type as ``self``

    OUTPUT:

    - the tensor resulting from the addition of ``self`` and ``other``
    ...
    """
    # No need for consistency check since self and other are guaranted
    # to belong to the same tensor module
    basis = self.common_basis(other)
    if basis is None:
        raise ValueError("no common basis for the addition")
    comp_result = self._components[basis] + other._components[basis]
    result = self._fmodule.tensor_from_comp(self._tensor_type, comp_result)
    if self._name is not None and other._name is not None:
        result._name = self._name + '+' + other._name
    if self._latex_name is not None and other._latex_name is not None:
        result._latex_name = self._latex_name + '+' + other._latex_name
    return result
File:   .../site-packages/sage/tensor/modules/free_module_tensor.py
\end{lstlisting}
From line~26, we see that this method \code{\_add\_()} is implemented
at the level of tensors on free modules, i.e. in the class
\code{FreeModuleTensor}\footurl{http://doc.sagemath.org/html/en/reference/tensor_free_modules/sage/tensor/modules/free_module_tensor.html}, from which \code{VectorFieldParal} inherits (cf. the diagram in
Fig.~\ref{f:vec:tensorfield_classes}). Here the free module is clearly
$\mathfrak{X}(U)$. The addition amounts to adding the components in a
basis of the free module in which both operands have known components. Such
a basis is returned by the method \code{common\_basis} invoked in line~16.
If necessary, this method can use change-of-basis formulas to compute the
components of \code{self} or \code{other} in a common basis.
The addition of the components in the found basis is performed in line~19. It
involves the method \code{\_\_add\_\_()} of class \code{Components}; we
can examine the corresponding code via the object \code{vUc} since the
latter has been defined above as \code{vUc = vU.\_components[eU]}, i.e.
\code{vUc} represents the set of components of the vector field
$\left. \w{v}\right| _U$ in the basis \code{eU} $=(\partial/\partial x, \partial/\partial y)$
of $\mathfrak{X}(U)$:
\jup{ve77.png}
\begin{lstlisting}
def __add__(self, other):
    """
    Component addition.

    INPUT:

    - ``other`` -- components of the same number of indices and defined
      on the same frame as ``self``

    OUTPUT:

    - components resulting from the addition of ``self`` and ``other``
    ...
    """
    ...
    result = self.copy()
    nproc = Parallelism().get('tensor')
    if nproc != 1 :
        # Parallel computation
        ...
    else:
        # Sequential computation
        for ind, val in other._comp.items():
            result[[ind]] += val
    return result
File:   .../site-packages/sage/tensor/modules/comp.py
\end{lstlisting}
First of all, we note from line~26
that this is not the method \code{\_\_add\_\_()} of class \code{Element},
as it was for \code{VectorField} and \code{VectorFieldParal},
but instead the method \code{\_\_add\_\_()} implemented
in class \code{Components}. This is because \code{Components} is a
\emph{technical} class, as opposed to the \emph{mathematical} classes
\code{VectorField} and \code{DiffScalarField}; therefore it does not
inherits from \code{Element}, but only from the base class \code{SageObject},
which does not implement any addition.
We note from lines~17-19 that the computation can be parallelized on the
components if the user has turned on parallelization\footnote{This is done with the command
\code{Parallelism().set(nproc=8)} (for 8 threads); many examples of
parallelized computations are presented at
\url{http://sagemanifolds.obspm.fr/examples.html}.}. Focusing on the sequential code
(lines~23-24), we see that the addition is
performed component by component. Each component being an element of
$C^\infty(U)$ --- the base ring of $\mathfrak{X}(U)$ ---, this addition is that
of scalar fields, as discussed in Sec.~\ref{s:man:add_implement}.

\subsection{Action of vector fields on scalar fields} \label{s:vec:action_on_scalar}

The action of $\w{v}$ on $f$ is defined pointwise by
considering $\w{v}$ at each point $p\in M$ as a derivation (the very definition of a tangent vector, cf. Sec.~\ref{s:vec:def_tangent_vector}); the result is then a
scalar field $\w{v}(f)$ on $M$:
\jup{ve78.png}
\jup{ve79.png}
